import GeossSearchApiService from '@/services/geoss-search.api.service'
import { GeneralFiltersGetters } from '~/store/generalFilters/general-filters-getters'
import { GeneralFiltersActions } from '~/store/generalFilters/general-filters-actions'
import { FacetedFiltersActions } from '~/store/facetedFilters/faceted-filters-actions'
import { FacetedFiltersGetters } from '~/store/facetedFilters/faceted-filters-getters'
import { GranulaFiltersGetters } from '~/store/granulaFilters/granula-filters-getters'
import { GranulaFiltersActions } from '~/store/granulaFilters/granula-filters-actions'
import { IrisFiltersActions } from '~/store/irisFilters/iris-filters-actions'
import { IRIS_CATALOG } from '~/data/general-filters'
import { IrisFiltersGetters } from '~/store/irisFilters/iris-filters-getters'
import { PopupActions } from '../popup/popup-actions'
import LogService from '@/services/log.service'
import { AppVueObj } from '~/data/global'
import UtilsService from '@/services/utils.service'
import {
    DataSources,
    DataSource,
    DataSourcesMask,
    AlternateSourcesMap,
    DataSourceGroup,
} from '@/interfaces/DataSources'
import to from '@/utils/to'
import { SearchActions } from './search-actions'
import { ParentRef } from '@/interfaces/ParentRef'
import ConfirmSearchPopup from '@/components/Search/ConfirmSearchPopup.vue'
import ErrorPopup from '@/components/ErrorPopup.vue'
import { SearchEngineGetters } from '~/store/searchEngine/search-engine-getters'
import Vue from 'vue'
import { $tc } from '~/plugins/i18n'
import { InSituFiltersActions } from '../inSituFilters/inSitu-filters.actions'
import { InSituFiltersGetters } from '../inSituFilters/inSitu-filters.getters'

declare global {
    interface Window {
        [x: string]: any
    }
}

const totalResultsProp = 'totalResults'
const totalResultsOpenSearchProp = 'opensearch:totalResults'

const state = () => ({
    dataSource: null,
    dabResults: null,
    dataResults: null,
    amerigeossResults: null,
    nextgeossResults: null,
    informationResults: null,
    servicesResults: null,
    zenodoResults: null,
    wikipediaResults: null,
    resultIdDetails: null,
    previousQueryParams: null,
    actionBeforeRequest: null,
    actionAfterSuccessRequest: null,
    actionAfterFailureRequest: null,
    actionAfterMetadataShow: null,
    actionAfterDownloadPopupShow: null,
    cancelConfirmSearch: false,
    searchJustSaved: false,
    workflow: null,
    workflowRunName: '',
    workflowInputId: null,
    workflowInputType: null,
    workflowParents: null,
    workflowProdType: null,
    workflowSources: null,
    workflowResource: null,
    workflowPlatformData: {},
    workflowPlatformDataLoading: 0,
    workflowCloudPlatforms: [
        {
            description: 'AWS',
            id: 'essicore',
            title: 'AWS',
        },
        {
            description: 'European Open Science Cloud',
            id: 'essieosc-vlab',
            title: 'European Open Science Cloud',
        },
        {
            description: 'CreoDIAS platform',
            id: 'essicreodias-vlab',
            title: 'CreoDIAS',
        },
    ],
    workflowSelectedPlatform: {},
    workflowOptimalPlatform: '',
    workflowCoordinates: null,
    workflowPredefined: {
        uniquePlatformSettings: [
            {
                // EODESM - Sentinel 2
                fieldModel: 'sat_product',
                settings: {
                    parents:
                        'satellitescene_collection_prefix_SENTINEL_2A,satellitescene_collection_prefix_SENTINEL_2B',
                    prodType: 'S2MSI2A',
                },
            },
        ],
        defaultInputValues: [
            {
                // Trends Earth v1
                workflowId:
                    'http://eu.essi_lab.vlab.core/workflow/autogenerated-1664543852740-process',
                defaultValues: {
                    trendsearth_lc:
                        'https://ecopotentialdemoinput.s3.amazonaws.com/trends/europe-lc.zip',
                    trendsearth_p:
                        'https://ecopotentialdemoinput.s3.amazonaws.com/trends/europe-p.zip',
                    trendsearth_soc:
                        'https://ecopotentialdemoinput.s3.amazonaws.com/trends/europe-soc.zip',
                },
            },
        ],
        workflowViews: [
            {
                // Trends Earth v1
                workflowId:
                    'http://eu.essi_lab.vlab.core/workflow/autogenerated-1664543852740-process',
                workflowView: {
                    sources: 'trendsearthID',
                },
            },
        ],
    },
    startIndex: {
        dab: 1,
        data: 1,
        amerigeoss: 1,
        nextgeoss: 1,
        information: 1,
        zenodo: 1,
        wikipedia: 1,
        services: 1,
    },
    hiddenDataSources: [
        // 'data',
        // 'amerigeoss',
        // 'nextgeoss',
        // 'information',
        // 'zenodo',
        // 'wikipedia',
        // 'services',
    ],
    freezeDataSources: [],
    parentRefs: [],
    parentIds: '',
    keyword: '',
    recentSeeAlsoPhrases: [],
    recentSeeAlsoRecommendations: [],
    otherSourcesLoading: false,
    showDetailsTrigger: false,
    targetIds: '',
    highlightResult: '',
    crRelation: null,
    crRelationParams: null,
    longRequestInfo: null,
})

const initialState = JSON.parse(JSON.stringify(state()))

const getters: { [key: string]: any } = {
    resultsActive: (state: any) => {
        return !!(
            state.dabResults ||
            state.dataResults ||
            state.amerigeossResults ||
            state.nextgeossResults ||
            state.informationResults ||
            state.zenodoResults ||
            state.wikipediaResults ||
            state.servicesResults
        )
    },
    searchJustSaved: (state: any) => {
        return state.searchJustSaved
    },
    currentResults: (state: any) => {
        return state[`${state.dataSource}Results`]
    },
    resultIdDetails: (state: any) => {
        return state.resultIdDetails
    },
    dabResults: (state: any) => {
        return state.dabResults
    },
    dataResults: (state: any) => {
        return state.dataResults
    },
    amerigeossResults: (state: any) => {
        return state.amerigeossResults
    },
    nextgeossResults: (state: any) => {
        return state.nextgeossResults
    },
    informationResults: (state: any) => {
        return state.informationResults
    },
    zenodoResults: (state: any) => {
        return state.zenodoResults
    },
    wikipediaResults: (state: any) => {
        return state.wikipediaResults
    },
    servicesResults: (state: any) => {
        return state.servicesResults
    },
    previousQueryParams: (state: any) => {
        return state.previousQueryParams
    },
    currentResultsEndIndex: (state: any, getters: any) => {
        const currentResults = state[`${state.dataSource}Results`]
        if (currentResults) {
            if (state.dataSource === 'zenodo') {
                let endIndex =
                    getters.startIndexes.zenodo + getters.resultsPerPage - 1
                if (endIndex > state.zenodoResults[totalResultsProp]) {
                    endIndex = state.zenodoResults[totalResultsProp]
                }
                return endIndex
            } else {
                let endIndex =
                    getters.startIndex[state.dataSource] +
                    getters.resultsPerPage -
                    1
                if (endIndex > currentResults.totalResults) {
                    endIndex = currentResults.totalResults
                }
                return endIndex
            }
        }
        return null
    },
    currentResultsTotal: (state: any) => {
        switch (state.dataSource) {
            case DataSources.DAB:
                return state.dabResults ? state.dabResults.totalResults : null
            case DataSources.DATA:
                return state.dataResults
                    ? state.dataResults[totalResultsOpenSearchProp]
                    : null
            case DataSources.AMERIGEOSS:
                return state.amerigeossResults
                    ? state.amerigeossResults[totalResultsOpenSearchProp]
                    : null
            case DataSources.NEXTGEOSS:
                return state.nextgeossResults
                    ? state.nextgeossResults[totalResultsOpenSearchProp]
                    : null
            case DataSources.INFORMATION:
                return state.informationResults
                    ? state.informationResults[totalResultsOpenSearchProp]
                    : null
            case DataSources.ZENODO:
                return state.zenodoResults
                    ? state.zenodoResults[totalResultsProp]
                    : null
            case DataSources.WIKIPEDIA:
                return state.wikipediaResults
                    ? state.wikipediaResults[totalResultsOpenSearchProp]
                    : null
            case DataSources.SERVICES:
                return state.servicesResults
                    ? state.servicesResults[totalResultsOpenSearchProp]
                    : null
        }
    },
    filtersParams: (getters: any, rootGetters: any) => {
        let params = {
            ...AppVueObj.app.$store.getters[GeneralFiltersGetters.stateMapped],
            ...AppVueObj.app.$store.getters[FacetedFiltersGetters.stateMapped],
        }

        if (getters.workflow && getters.workflowInputId) {
            // Temporary VLAB Sentinel2-only Support
            if (getters.workflowParents && getters.workflowProdType) {
                params.parents = getters.workflowParents
                params.prodType = getters.workflowProdType
                params.tf = 'prodType,sensorOpMode'
                delete params.st
                params = {
                    ...params,
                    ...AppVueObj.app.$store.getters[
                        GranulaFiltersGetters.stateMapped
                    ],
                }
            } else if (getters.workflowSources) {
                params.sources = getters.workflowSources
            } else {
                params.workflowid = getters.workflow.id
                params.workflowinputid = getters.workflowInputId
            }
        }

        if (getters.parentRef) {
            params.parents = getters.parentRef.id
            delete params.st

            let queryablesForEntries =
                getters.parentRef.entry.satelliteCollectionQueryable

            if (queryablesForEntries) {
                queryablesForEntries = queryablesForEntries
                    .split(',')
                    .filter(
                        (item: any) =>
                            AppVueObj.app.$store.getters[
                                GranulaFiltersGetters.availableQueryable
                            ].indexOf(item) !== -1
                    )
                    .join(',')
                params.tf = queryablesForEntries
            } else {
                delete params.tf
            }

            params = {
                ...params,
                ...AppVueObj.app.$store.getters[
                    GranulaFiltersGetters.stateMapped
                ],
            }
        } else if (
            AppVueObj.app.$store.getters[GeneralFiltersGetters.state] &&
            AppVueObj.app.$store.getters[GeneralFiltersGetters.state].sources
                .length === 1 &&
            AppVueObj.app.$store.getters[GeneralFiltersGetters.state]
                .sources[0] === IRIS_CATALOG
        ) {
            params = {
                ...params,
                ...AppVueObj.app.$store.getters[IrisFiltersGetters.stateMapped],
            }
        }

        if(params.viewid === 'worldcereal'){
            params = {
                ...params,
                ...AppVueObj.app.$store.getters[InSituFiltersGetters.stateMapped],
            }
        }

        return params
    },
    actionBeforeRequest: (state: any) => {
        return state.actionBeforeRequest
    },
    actionAfterSuccessRequest: (state: any) => {
        return state.actionAfterSuccessRequest
    },
    actionAfterFailureRequest: (state: any) => {
        return state.actionAfterFailureRequest
    },
    actionAfterMetadataShow: (state: any) => {
        return state.actionAfterMetadataShow
    },
    actionAfterDownloadPopupShow: (state: any) => {
        return state.actionAfterDownloadPopupShow
    },
    shareParams: (state: any) => {
        let params = ''
        const includeParams = ['parentRefs', 'dataSource', 'startIndex']
        for (const prop in initialState) {
            if (
                includeParams.indexOf(prop) !== -1 &&
                JSON.stringify(state[prop]) !==
                    JSON.stringify(initialState[prop])
            ) {
                let value = state[prop]
                if (prop === 'parentRefs') {
                    value = value || []
                    const parentRef = value.slice(-1)[0]
                    if (!parentRef) {
                        continue
                    } else {
                        value = JSON.stringify([
                            {
                                id: parentRef.id,
                                dataSource: parentRef.dataSource,
                            },
                        ])
                    }
                } else if (prop === 'startIndex') {
                    if (
                        value[state.dataSource] !==
                        initialState.startIndex[state.dataSource]
                    ) {
                        value = value[state.dataSource]
                    } else {
                        value = ''
                    }
                }

                if (value) {
                    if (params) {
                        params += '&'
                    }
                    params += `f:${prop}=${encodeURIComponent(value)}`
                }
            }
        }
        if (params) {
            params += '&'
        }
        return params
    },
    cancelConfirmSearch: (state: any) => {
        return state.cancelConfirmSearch
    },
    dataSource: (state: any) => {
        return state.dataSource
    },
    workflow(state: any) {
        return state.workflow
    },
    workflowRunName(state: any) {
        return state.workflowRunName
    },
    workflowInputId(state: any) {
        return state.workflowInputId
    },
    workflowResource(state: any) {
        return state.workflowResource
    },
    workflowInputType(state: any) {
        return state.workflowInputType
    },
    workflowParents(state: any) {
        return state.workflowParents
    },
    workflowProdType(state: any) {
        return state.workflowProdType
    },
    workflowSources(state: any) {
        return state.workflowSources
    },
    workflowPlatformData(state: any) {
        return state.workflowPlatformData
    },
    workflowPlatformDataLoading(state: any) {
        return state.workflowPlatformDataLoading
    },
    workflowCloudPlatforms(state: any) {
        return state.workflowCloudPlatforms
    },
    workflowSelectedPlatform(state: any) {
        return state.workflowSelectedPlatform
    },
    workflowOptimalPlatform(state: any) {
        return state.workflowOptimalPlatform
    },
    workflowCoordinates(state: any) {
        return state.workflowCoordinates
    },
    workflowPredefined(state: any) {
        return state.workflowPredefined
    },
    startIndex(state: any) {
        return state.startIndex[state.dataSource]
    },
    startIndexes(state: any) {
        return state.startIndex
    },
    hiddenDataSources(state: any) {
        return state.hiddenDataSources
    },
    freezeDataSources(state: any) {
        return state.freezeDataSources
    },
    parentRef(state: any) {
        return state.parentRefs ? state.parentRefs.slice(-1)[0] : null
    },
    parentRefs(state: any) {
        return state.parentRefs ? state.parentRefs : []
    },
    parentIds(state: any) {
        return state.parentIds ? state.parentIds : ''
    },
    keyword(state: any) {
        return state.keyword
    },
    recentSeeAlsoPhrases(state: any) {
        return state.recentSeeAlsoPhrases
    },
    recentSeeAlsoRecommendations(state: any) {
        return state.recentSeeAlsoRecommendations
    },
    otherSourcesLoading(state: any) {
        return state.otherSourcesLoading
    },
    showDetailsTrigger(state: any) {
        return state.showDetailsTrigger
    },
    targetIds(state: any) {
        return state.targetIds
    },
    highlightResult(state: any) {
        return state.highlightResult
    },
    crRelation(state: any) {
        return state.crRelation
    },
    crRelationParams(state: any) {
        return state.crRelationParams
    },
    longRequestInfo(state: any) {
        return state.longRequestInfo
    },
}

const mutations = {
    setStateProp(state: any, data: { prop: any; value: any }) {
        state[data.prop] = data.value
    },
    updateDabResultRating(
        state: any,
        { id, rating }: { id: string; rating: any }
    ) {
        const results = state[`${state.dataSource}Results`]
        if (results && results.entry) {
            const result = results.entry.find(
                (item: { id: string }) => item.id === id
            )
            if (result) {
                result.rating = rating
            }
        }
    },
    setPreviousQueryParams(state: any, params: any) {
        let newQueryParams = null
        if (params) {
            const copyParams = JSON.parse(JSON.stringify(params))
            delete copyParams.reqID
            delete copyParams.ct
            newQueryParams = JSON.stringify(copyParams)
        }
        state.previousQueryParams = newQueryParams
    },
    addParentRef(state: any, value: ParentRef) {
        state.parentRefs = state.parentRefs || []
        state.parentRefs = state.parentRefs.concat([value])
    },
    popParentRef(state: any) {
        if (state.parentRefs || state.parentRefs.length) {
            state.parentRefs.pop()
            state.parentRefs = state.parentRefs.slice()
        }
    },
}

const actions = {
    async getResults(
        {
            state,
            dispatch,
            commit,
            getters,
            rootGetters,
        }: { [key: string]: any },
        data: {
            replaceHistory?: boolean
            theSameTab?: boolean
            noPushToHistory?: boolean
            targetSource?: any
            fetchOtherSources?: boolean
            theSameSource?: boolean
        } = {}
    ) {
        const fetchOtherSources = !!data.fetchOtherSources
            ? data.fetchOtherSources
            : false
        data.noPushToHistory = data.noPushToHistory || getters.workflow
        if (!data.theSameTab && !data.replaceHistory) {
            dispatch(SearchActions.setStartIndex, { value: 1 }, { root: true })
        }

        const generalFilters: any =
            AppVueObj.app.$store.getters[GeneralFiltersGetters.state]

        dispatch(GeneralFiltersActions.setContainerVisible, false, {
            root: true,
        })
        dispatch(GranulaFiltersActions.checkParamsAvailability, null, {
            root: true,
        })

        LogService.logSearchResult(
            'search_query',
            null,
            null,
            AppVueObj.app.$store.getters[GeneralFiltersGetters.state].phrase,
            'dab',
            'viewed'
        )

        let lastPhrase = null
        if (AppVueObj.storeStateBackup) {
            lastPhrase = JSON.parse(AppVueObj.storeStateBackup).generalFilters
                .phrase
        }
        if (
            !getters.cancelConfirmSearch &&
            (!getters.previousQueryParams ||
                lastPhrase !==
                    AppVueObj.app.$store.getters[GeneralFiltersGetters.state]
                        .phrase)
        ) {
            const [, data] = await to(
                GeossSearchApiService.checkIfQueryLocation(
                    AppVueObj.app.$store.getters[GeneralFiltersGetters.state]
                        .phrase
                )
            )
            if (data) {
                dispatch(GeneralFiltersActions.setGooglePlacesApiError, '', {
                    root: true,
                })
                const props = {
                    location: data.name,
                    query: data.updatedQuery,
                }
                const [, result] = await to(
                    dispatch(
                        PopupActions.openPopup,
                        {
                            contentId: 'confirm-search',
                            component: ConfirmSearchPopup,
                            props,
                        },
                        { root: true }
                    )
                )
                if (result && result !== 'cancel') {
                    dispatch(
                        GeneralFiltersActions.setPhrase,
                        data.updatedQuery,
                        { root: true }
                    )
                    dispatch(
                        GeneralFiltersActions.setBoundingBoxRelation,
                        'OVERLAPS',
                        { root: true }
                    )
                    await dispatch(
                        GeneralFiltersActions.setGooglePlacesInput,
                        data.name,
                        { root: true }
                    )
                    await dispatch(
                        GeneralFiltersActions.setSelectedAreaCoordinates,
                        data.coordinate,
                        { root: true }
                    )
                    await AppVueObj.app.$nextTick()
                    dispatch(GeneralFiltersActions.setInChangeProcess, false, {
                        root: true,
                    })
                }
            }
        }

        commit('setStateProp', { prop: 'cancelConfirmSearch', value: false })
        if (getters.actionBeforeRequest) {
            const returnVal = getters.actionBeforeRequest()
            if (returnVal && returnVal.then) {
                await to(returnVal)
            }
        }
        if (
            getters.filtersParams &&
            getters.filtersParams.searchFields &&
            AppVueObj.app.$store.getters[
                GeneralFiltersGetters.additionalSearchFields
            ] !== ''
        ) {
            const currentSearchFields =
                getters.filtersParams.searchFields.split(',')
            const addedSeachFields =
                AppVueObj.app.$store.getters[
                    GeneralFiltersGetters.additionalSearchFields
                ].split(',')
            getters.filtersParams.searchFields = currentSearchFields
                .concat(
                    addedSeachFields.filter(
                        (e: any) => currentSearchFields.indexOf(e) < 0
                    )
                )
                .join()
            dispatch(GeneralFiltersActions.setAdditionalSearchFields, '', {
                root: true,
            })
        }

        const [err, results] = await to(
            GeossSearchApiService.getResults(
                getters.filtersParams,
                getters.workflow,
                data.theSameTab,
                data.targetSource,
                data.theSameSource
            )
        )

        if (!results && err) {
            const errorInfo = {
                title: (
                    AppVueObj.app.$txs('general.backendError') as string
                ).toUpperCase(),
                subtitle: $tc('general.errorOccurred'),
                description: err.toString(),
            }
            dispatch(
                PopupActions.openPopup,
                { contentId: 'error', component: ErrorPopup, props: errorInfo },
                { root: true }
            )
            return
        }

        for (const result of Object.keys(results)) {
            if (results[result]) {
                results[result].facetedFilters = {}
                if (result.includes(getters.dataSource)) {
                    for (const filter of Object.keys(getters.filtersParams)) {
                        if (
                            [
                                'kwd',
                                'frmt',
                                'sources',
                                'prot',
                                'organisationName',
                                'sscScore',
                            ].includes(filter)
                        ) {
                            results[result].facetedFilters[filter] =
                                getters.filtersParams[filter]
                        }
                    }
                }
            }
        }
        let currentResults = getters.workflow ? results.dabResults : null
        if (!currentResults) {
            currentResults = results[`${state.dataSource}Results`]
        }
        if (!state.workflowInputId && !UtilsService.getUrlParam('targetId')) {
            dispatch('setResultIdDetails', null)
        }
        if (currentResults && currentResults.error) {
            if (
                currentResults.error !== 'cancel' &&
                getters.actionAfterFailureRequest
            ) {
                getters.actionAfterFailureRequest(currentResults.error)
            } else {
                let errorInfo: { [key: string]: any } | null = {
                    title: null,
                    subtitle: null,
                    description: null,
                }
                switch (currentResults.error) {
                    case 'no_results': {
                        const otherAvailableSourceResults: Array<DataSource> =
                            []
                        for (const key in results) {
                            if (!results[key].error) {
                                otherAvailableSourceResults.push(
                                    DataSourcesMask[
                                        results[key].dataSource
                                    ] as DataSource
                                )
                            }
                        }
                        if (!otherAvailableSourceResults.length) {
                            errorInfo.title = (
                                Vue.prototype.$nuxt.$options.i18n.t(
                                    'general.noResourcesFound'
                                ) as string
                            ).toUpperCase()
                            errorInfo.subtitle = $tc(
                                'general.unableToFindAnyResources'
                            )
                        } else {
                            errorInfo = null
                            // If possible run other datasource from the same tab
                            const currentTab =
                                DataSourceGroup[state.dataSource as DataSource]
                            const otherSourcesFromCurrentTab =
                                otherAvailableSourceResults.filter(
                                    (item) =>
                                        DataSourceGroup[item] === currentTab
                                )
                            if (otherSourcesFromCurrentTab.length) {
                                dispatch(
                                    SearchActions.setDataSource,
                                    { value: otherSourcesFromCurrentTab[0] },
                                    { root: true }
                                )
                            } else {
                                dispatch(
                                    SearchActions.setDataSource,
                                    { value: otherAvailableSourceResults[0] },
                                    { root: true }
                                )
                            }
                        }
                        break
                    }
                    case 'timeout': {
                        errorInfo.title = (
                            $tc('general.warning') as string
                        ).toUpperCase()
                        errorInfo.subtitle = $tc(
                            'general.loadingResourcesIsTakingTooLong'
                        )
                        break
                    }
                    case 'cancel': {
                        errorInfo = null
                        break
                    }
                    default: {
                        errorInfo.title = (
                            $tc('general.backendError') as string
                        ).toUpperCase()
                        errorInfo.subtitle = $tc('general.errorOccurred')
                        errorInfo.description = currentResults.error
                    }
                }

                if (errorInfo) {
                    dispatch(
                        PopupActions.openPopup,
                        {
                            contentId: 'error',
                            component: ErrorPopup,
                            props: errorInfo,
                        },
                        { root: true }
                    )
                }
            }

            for (const prop of Object.keys(results)) {
                const result = results[prop]
                if (
                    (!data.theSameTab && result && !result.error) ||
                    (data.theSameTab && result === currentResults)
                ) {
                    commit('setStateProp', { prop, value: result })
                } else if (!data.theSameTab) {
                    commit('setStateProp', { prop, value: null })
                }
            }

            if (data.theSameTab && currentResults.error) {
                UtilsService.popFromHistory()
                setTimeout(() => {
                    dispatch('setPreviousQueryParams', getters.filtersParams)
                }, 0)

                return Promise.resolve()
            }
        } else {
            for (const prop of Object.keys(results)) {
                const result = results[prop]
                if (
                    (!data.theSameTab && result && !result.error) ||
                    (data.theSameTab && result === currentResults)
                ) {
                    commit('setStateProp', {
                        prop,
                        value: result,
                    })
                } else if (!data.theSameTab) {
                    commit('setStateProp', { prop, value: null })
                }
            }

            if (
                (getters.parentRef &&
                    getters.parentRef.dataSource === DataSources.DAB) ||
                (getters.workflowParents &&
                    getters.workflowParents.includes('satellitescene'))
            ) {
                dispatch(
                    FacetedFiltersActions.setFacetedFiltersAvailable,
                    false,
                    { root: true }
                )
                dispatch(
                    GranulaFiltersActions.setGranulaFiltersAvailable,
                    true,
                    { root: true }
                )
                dispatch(IrisFiltersActions.setIrisFiltersAvailable, false, {
                    root: true,
                })
            } else if (
                generalFilters.sources.length === 1 &&
                generalFilters.sources[0] === IRIS_CATALOG
            ) {
                dispatch(
                    FacetedFiltersActions.setFacetedFiltersAvailable,
                    false,
                    { root: true }
                )
                dispatch(
                    GranulaFiltersActions.setGranulaFiltersAvailable,
                    false,
                    { root: true }
                )
                dispatch(IrisFiltersActions.setIrisFiltersAvailable, true, {
                    root: true,
                })
            } else {
                dispatch(
                    FacetedFiltersActions.setFacetedFiltersAvailable,
                    true,
                    { root: true }
                )
                dispatch(
                    GranulaFiltersActions.setGranulaFiltersAvailable,
                    false,
                    { root: true }
                )
                dispatch(IrisFiltersActions.setIrisFiltersAvailable, false, {
                    root: true,
                })
            }

            if (
                AppVueObj.app.$store.getters[
                    GeneralFiltersGetters.getViewId
                ].includes('worldcereal')
            ) {
                dispatch(InSituFiltersActions.setInSituFiltersAvailable, true, {
                    root: true,
                })
            } else {
                dispatch(InSituFiltersActions.setInSituFiltersAvailable, false, {
                    root: true,
                })
            }

            if (getters.actionAfterSuccessRequest) {
                getters.actionAfterSuccessRequest()
            }

            if (
                state.parentRefs &&
                state.parentRefs.length &&
                !getters.otherSourcesLoading &&
                fetchOtherSources
            ) {
                const entryIds = []
                if (currentResults.entry.length) {
                    for (const result of currentResults.entry) {
                        entryIds.push(result.id)
                    }

                    const freezedSources = []
                    const currentTab =
                        DataSourceGroup[getters.dataSource as DataSource]
                    for (const source in DataSourceGroup) {
                        if (
                            DataSourceGroup[source as DataSource] === currentTab
                        ) {
                            freezedSources.push(source)
                        }
                    }

                    dispatch(
                        SearchActions.setParentIds,
                        encodeURIComponent(entryIds.join()),
                        { root: true }
                    )
                    dispatch(
                        SearchActions.setFreezeDataSources,
                        freezedSources,
                        { root: true }
                    )
                    dispatch(SearchActions.setOtherSourcesLoading, true, {
                        root: true,
                    })
                    dispatch(
                        SearchActions.getResults,
                        { noPushToHistory: true, fetchOtherSources: false },
                        { root: true }
                    )
                }
            }
        }

        if (!data.noPushToHistory) {
            /**
             * this timeout is necessary because after results
             * have been retrieved, filters components react on
             * changes on those results and put appropriate values.
             * And we need to set previous query params after those
             * values have been assigned.
             */
            setTimeout(() => {
                dispatch('setPreviousQueryParams', getters.filtersParams)
                UtilsService.pushToHistory(data.replaceHistory)
            }, 0)
        }

        dispatch(SearchActions.setSearchJustSaved, false, { root: true })
        return Promise.resolve()
    },
    clearResults: (context: any) => {
        context.commit('setStateProp', { prop: 'dabResults', value: null })
        context.commit('setStateProp', { prop: 'dataResults', value: null })
        context.commit('setStateProp', {
            prop: 'amerigeossResults',
            value: null,
        })
        context.commit('setStateProp', {
            prop: 'nextgeossResults',
            value: null,
        })
        context.commit('setStateProp', {
            prop: 'informationResults',
            value: null,
        })
        context.commit('setStateProp', { prop: 'zenodoResults', value: null })
        context.commit('setStateProp', {
            prop: 'wikipediaResults',
            value: null,
        })
        context.commit('setStateProp', { prop: 'servicesResults', value: null })
        AppVueObj.storeStateBackup = null
    },
    async addParentRef({ state, commit }: any, value: ParentRef) {
        if (!value.entry) {
            const [, result] = await to(
                GeossSearchApiService.getTargetById(value.id, state.datasource)
            )
            value.entry = result
        }
        return commit('addParentRef', value)
    },
    popParentRef({ commit }: any) {
        return commit('popParentRef')
    },
    async setParentRefs({ state, commit }: any, value: ParentRef[]) {
        if (value && value.length) {
            if (!value[0].entry) {
                const [, result] = await to(
                    GeossSearchApiService.getTargetById(
                        value[0].id,
                        state.datasource
                    )
                )
                value[0].entry = result.entry[0]
            }
        }
        commit('setStateProp', { prop: 'parentRefs', value })
    },
    setSearchJustSaved({ commit }: any, value: boolean) {
        commit('setStateProp', { prop: 'searchJustSaved', value })
    },
    setResultIdDetails({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'resultIdDetails', value })
    },
    updateDabResultRating({ commit }: any, data: { id: string; rating: any }) {
        commit('updateDabResultRating', data)
    },
    setPreviousQueryParams({ commit }: any, value: string) {
        commit('setPreviousQueryParams', value)
    },
    setDabResults({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'dabResults', value })
    },
    setInformationResults({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'informationResults', value })
    },
    setServicesResults({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'servicesResults', value })
    },
    setDataResults({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'dataResults', value })
    },
    setAmerigeossResults({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'amerigeossResults', value })
    },
    setNextgeossResults({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'nextgeossResults', value })
    },
    setZenodoResults({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'zenodoResults', value })
    },
    setWikipediaResults({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'wikipediaResults', value })
    },
    setActionBeforeRequest(
        { commit }: any,
        value: (() => void | Promise<any>) | null
    ) {
        commit('setStateProp', { prop: 'actionBeforeRequest', value })
    },
    setActionAfterSuccessRequest(
        { commit }: any,
        value: (() => void | Promise<any>) | null
    ) {
        commit('setStateProp', { prop: 'actionAfterSuccessRequest', value })
    },
    setActionAfterFailureRequest(
        { commit }: any,
        value: (() => void | Promise<any>) | null
    ) {
        commit('setStateProp', { prop: 'actionAfterFailureRequest', value })
    },
    setActionAfterMetadataShow(
        { commit }: any,
        value: (() => void | Promise<any>) | null
    ) {
        commit('setStateProp', { prop: 'actionAfterMetadataShow', value })
    },
    setActionAfterDownloadPopupShow(
        { commit }: any,
        value: (() => void | Promise<any>) | null
    ) {
        commit('setStateProp', { prop: 'actionAfterDownloadPopupShow', value })
    },
    setCancelConfirmSearch({ commit }: any, value: boolean) {
        commit('setStateProp', { prop: 'cancelConfirmSearch', value })
    },
    setDataSource(
        { commit, rootGetters, state }: any,
        data: { value: string; checkDefault?: boolean }
    ) {
        const defaultSourceName =
            AppVueObj.app.$store.getters[SearchEngineGetters.defaultSourceName]
        let value = data.value
        if (value && value.includes(',')) {
            value = value.split(',')[0] as DataSource
        }
        if (data.checkDefault && defaultSourceName) {
            for (const source in AlternateSourcesMap) {
                if (
                    !state.hiddenDataSources.includes(source) &&
                    defaultSourceName ===
                        AlternateSourcesMap[source as DataSource]
                ) {
                    value = source as DataSource
                    break
                }
            }
        }
        commit('setStateProp', { prop: 'dataSource', value })
    },
    setWorkflow({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'workflow', value })
    },
    setWorkflowRunName({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'workflowRunName', value })
    },
    setWorkflowInputId({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'workflowInputId', value })
    },
    setWorkflowResource({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'workflowResource', value })
    },
    setWorkflowInputType({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'workflowInputType', value })
    },
    setWorkflowParents({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'workflowParents', value })
    },
    setWorkflowProdType({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'workflowProdType', value })
    },
    setWorkflowSources({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'workflowSources', value })
    },
    setWorkflowPlatformData({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'workflowPlatformData', value })
    },
    setWorkflowPlatformDataLoading({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'workflowPlatformDataLoading', value })
    },
    setWorkflowCloudPlatforms({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'workflowCloudPlatforms', value })
    },
    setWorkflowSelectedPlatform({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'workflowSelectedPlatform', value })
    },
    setWorkflowOptimalPlatform({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'workflowOptimalPlatform', value })
    },
    setWorkflowCoordinates({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'workflowCoordinates', value })
    },
    setStartIndex(
        context: any,
        data: { value: number; dataSource?: DataSource }
    ) {
        const value = JSON.parse(JSON.stringify(context.state.startIndex))
        if (data.dataSource) {
            value[data.dataSource] = data.value
        } else {
            for (const prop of Object.keys(value)) {
                value[prop] = 1
            }
        }
        context.commit('setStateProp', { prop: 'startIndex', value })
    },
    setHiddenDataSources({ commit }: any, value: DataSource[]) {
        commit('setStateProp', { prop: 'hiddenDataSources', value })
    },
    setFreezeDataSources({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'freezeDataSources', value })
    },
    addFreezeDataSources({ commit }: any, value: string) {
        const frozenSources: string[] = state().freezeDataSources.filter(
            (f: string) => f !== value
        )
        frozenSources.concat([value])
        commit('setStateProp', {
            prop: 'freezeDataSources',
            value: frozenSources,
        })
    },
    removeFreezeDataSources({ commit }: any, value: string) {
        const frozenSources = state().freezeDataSources.filter(
            (f: string) => f !== value
        )
        commit('setStateProp', {
            prop: 'freezeDataSources',
            value: frozenSources,
        })
    },
    setKeyword({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'keyword', value })
    },
    setRecentSeeAlsoPhrases({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'recentSeeAlsoPhrases', value })
    },
    setRecentSeeAlsoRecommendations({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'recentSeeAlsoRecommendations', value })
    },
    setParentIds({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'parentIds', value })
    },
    setOtherSourcesLoading({ commit }: any, value: boolean) {
        commit('setStateProp', { prop: 'otherSourcesLoading', value })
    },
    showDetailsTrigger({ commit }: any, value: boolean) {
        commit('setStateProp', { prop: 'showDetailsTrigger', value })
    },
    setTargetIds({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'targetIds', value })
    },
    setHighlightResult({ commit }: any, value: string) {
        commit('setStateProp', { prop: 'highlightResult', value })
    },
    setCrRelation({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'crRelation', value })
    },
    setCrRelationParams({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'crRelationParams', value })
    },
    setLongRequestInfo({ commit }: any, value: any) {
        commit('setStateProp', { prop: 'longRequestInfo', value })
    },
    reset({ dispatch }: { dispatch: any }) {
        dispatch(SearchActions.setDabResults, null, { root: true })
        dispatch(SearchActions.setDataResults, null, { root: true })
        dispatch(SearchActions.setAmerigeossResults, null, { root: true })
        dispatch(SearchActions.setNextgeossResults, null, { root: true })
        dispatch(SearchActions.setInformationResults, null, { root: true })
        dispatch(SearchActions.setZenodoResults, null, { root: true })
        dispatch(SearchActions.setWikipediaResults, null, { root: true })
        dispatch(SearchActions.setServicesResults, null, { root: true })
        dispatch(SearchActions.setParentRefs, null, { root: true })
        const defaultDS = AppVueObj.app.$store.getters[SearchEngineGetters.defaultSourceName]
        dispatch(
            SearchActions.setDataSource,
            { value: defaultDS ? defaultDS : DataSources.DAB, checkDefault: true },
            { root: true }
        )
        dispatch(SearchActions.setPreviousQueryParams, null, { root: true })
        dispatch(SearchActions.setSearchJustSaved, false, { root: true })
        dispatch(SearchActions.setWorkflow, null, { root: true })
        dispatch(SearchActions.setWorkflowRunName, '', { root: true })
        dispatch(SearchActions.setWorkflowInputId, null, { root: true })
        dispatch(SearchActions.setWorkflowResource, null, { root: true })
        dispatch(SearchActions.setWorkflowInputType, null, { root: true })
        dispatch(SearchActions.setWorkflowParents, null, { root: true })
        dispatch(SearchActions.setWorkflowProdType, null, { root: true })
        dispatch(SearchActions.setWorkflowSources, null, { root: true })
        dispatch(SearchActions.setWorkflowPlatformData, {}, { root: true })
        dispatch(SearchActions.setWorkflowPlatformDataLoading, 0, {
            root: true,
        })
        dispatch(SearchActions.setWorkflowCloudPlatforms, [], { root: true })
        dispatch(SearchActions.setWorkflowSelectedPlatform, '', { root: true })
        dispatch(SearchActions.setWorkflowOptimalPlatform, '', { root: true })
        dispatch(SearchActions.setWorkflowCoordinates, {}, { root: true })
        dispatch(SearchActions.setStartIndex, { value: 1 }, { root: true })
        dispatch(SearchActions.setFreezeDataSources, [], { root: true })
        dispatch(SearchActions.setKeyword, '', { root: true })
        dispatch(SearchActions.setRecentSeeAlsoPhrases, [], { root: true })
        dispatch(SearchActions.setRecentSeeAlsoRecommendations, [], {
            root: true,
        })
        dispatch(SearchActions.setParentIds, '', { root: true })
        dispatch(SearchActions.setOtherSourcesLoading, false, { root: true })
        dispatch(SearchActions.showDetailsTrigger, false, { root: true })
        dispatch(SearchActions.setTargetIds, '', { root: true })
        dispatch(SearchActions.setHighlightResult, null, { root: true })
        dispatch(SearchActions.setCrRelation, null, { root: true })
        dispatch(SearchActions.setCrRelationParams, null, { root: true })
        dispatch(SearchActions.setLongRequestInfo, null, { root: true })
        GeossSearchApiService.clearCacheParams()
    },
}

export default {
    namespaced: true,
    state,
    getters,
    actions,
    mutations,
}
